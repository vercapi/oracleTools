#+TITLE: Oracle Tools

* Docker base  

** Base image

  All docker images are based on oracle-minion. This is an oracleLinux image with a saltstack minion installed on it.
  

*** Building the oracle-minion

    Actually build the base minion

    #+BEGIN_SRC sh :dir /sudo::/home/vercapi/Documents/projects/oracleTools/oracle-minion/ :results raw
    docker build -t vercapi/oracle_minion .
    #+END_SRC

*** Supplying the keys for an vercapi/oracle_minion container

    Generate a key move it to the master and supply it so that the docker image can be build with it.
    Before running the minion we need to setup some directories so that the salt state is persisted when the container is destroyed
    * minion.d is the directory to store configuration

    #+NAME: prep_minion
    #+HEADER: :var minion="minion.oracletools"
    #+BEGIN_SRC sh :dir /sudo::/home/vercapi/Documents/projects/oracleTools/oracle-minion/ :results raw
      KEY_NAME=preseed_key
      PUB_KEY_FILE_NAME=$KEY_NAME.pub
      PRIV_KEY_FILE_NAME=$KEY_NAME.pem

      # Prepare the mount points
      MINION_HOME=/srv/docker/volumes/$minion
      mkdir -p $MINION_HOME/etc/salt/minion.d
      mkdir -p $MINION_HOME/etc/salt/pki/minion

      salt-key --gen-keys=$KEY_NAME

      # Copy to master for the minion id $minion
      cp $PUB_KEY_FILE_NAME /etc/salt/pki/master/minions/$minion

      # Copy this to the minion directory
      cp $PRIV_KEY_FILE_NAME $MINION_HOME/etc/salt/pki/minion/minion.pem
      cp $PUB_KEY_FILE_NAME  $MINION_HOME/etc/salt/pki/minion/minion.pub


      # catch
      finish () {
          rm -f $PUB_KEY_FILE_NAME
          rm -f $PRIV_KEY_FILE_NAME
      }

      trap finish EXIT
    #+END_SRC

    #+RESULTS: prep_minion


*** Actually run the container
    
    Test run for the minion. Uses storage for the keys when running
    the bridge is needed so that the minion can connect to the salt master running on the host

    #+HEADER: :var minion="minion.oracletools"
    #+BEGIN_SRC sh :dir /sudo::/home/vercapi/Documents/projects/oracleTools/oracle-minion/ :results raw
      docker run -id -h $minion \
             --name $minion \
             -v /srv/docker/volumes/$minion/etc/salt/minion.d:/etc/salt/minion.d \
             -v /srv/docker/volumes/$minion/etc/salt/pki:/etc/salt/pki \
             --net="bridge" \
             vercapi/oracle_minion
    #+END_SRC

    #+RESULTS:
    4d65a45728964c7b4d9c2776e89b9a3a2c97029f7c6ebc71c7b1b0e66f80964a
    

** TODO Copy between

   To copy between systems.
   This should become the local repo.

   On source

   #+BEGIN_SRC sh
   docker save -o <save image to path> <image name>
   #+END_SRC

   #+BEGIN_SRC sh
   docker load -i <path to image tar file>
   #+END_SRC


* Database

** Preparation steps

   First run the installer to create a response file. Run ./runInstaller and select 'Save response file' on the bottom of the summary step. (This is the last step before actually installing anything) 
   Dowload the installation files from the Oracle Website. Im' using the 64 bit linux version 12.1.0.2.


** Docker

   For flexibility and avoiding full rebuilds we will create the docker in 2 steps. The first step will be creating a software 
   install on the image. The second will actually create a database. This gives the advantage that we can create different dockers
   with different databases based on the same base docker image with the software install.

   If you get an error on disk space add "--storage-opt dm.basesize=20G" to the startup. This will increase the max size of the container.

*** Build the docker for software only

    Docker file: oracleTools/software/database12.1.0.2.0/software/Dockerfile
    
    This docker will be a software only install there is no ready to use database. 

    To get a running database this image can be used to create a datacontainer that has a DB on it. The same image can be used to run the
    resulting container.

    Download of the software needs to happen manually.

    The response file oracleTools/software/database12.1.0.2.0/software/db.rsp contains info like the install directory what users and groups to use.
    You can also configure the starter db here as wel as grid options. None of the are used currently

    #+BEGIN_SRC sh :dir /sudo::/home/vercapi/Documents/projects/oracleTools/software/database12.1.0.2.0/software :results raw
      cp /mnt/localData/stage/linuxamd64_12102_database_1of2.zip ./
      cp /mnt/localData/stage/linuxamd64_12102_database_2of2.zip ./

      docker build -t vercapi/oracle_software121 .

      rm linuxamd64_12102_database_1of2.zip && rm linuxamd64_12102_database_2of2.zip
    #+END_SRC

    Running the docker with a shell to see the installation was successful. Starting the DB will not work but you can check the installed files.
    #+BEGIN_SRC sh :dir /sudo::/home/vercapi/Documents/projects/oracleTools/software/database12.1.0.2.0/software :results raw
      docker run -i -t --rm=true vercapi/oracle_software121 /bin/bash
    #+END_SRC

    In the container you can check the log files produced in the install command or subsequent scripts.

**** Main script

     This script is the startup script for the DB. It will allow creating a DB or running it

     #+BEGIN_SRC sh :tangle database12.1.0.2.0/software/run.sh
       #!/bin/bash
       # Simply run the database
       function runDB() {
           echo 'Starting DB'
           lsnrctl start
           sqlplus / as sysdba <<EOF
           startup;
       EOF

       }

       function checkDBExists() {
          # No entry in oratab, DB doesn't exist yet
          if [ "`grep $ORACLE_SID /etc/oratab`" == "" ]; then
             echo 0;
          else
             echo 1;
          fi;
       }

       function explain() {
           echo "use --run or --create"
       }

       # We always want to start the minion
       #sudo salt-minion &

       while [[ $# -ge 1 ]]
       do
           key="$1"

           case $key in
               --create)
                   if [ "`checkDBExists`" == "0" ]; then
                       /home/oracle/scripts/create_db.sh
                   else
                       echo "DB already exists"
                   fi;
                   shift
                   ;;
               --run)
                   if [ "`checkDBExists`" == "1" ]; then
                       runDB "$@"
                   else
                       echo "No DB exists already"
                   fi;
                   shift
                   ;;
               ,*)
                   explain
                   ;;
           esac
           shift
       done
     #+END_SRC


*** Database volume creation

    Simply start a container with no volume to create a DB
    #+BEGIN_SRC sh :tangle database12.1.0.2.0/create_new.sh
    docker run -i -t -h $1 --name $1 -p 1521:1521 vercapi/oracle_software121 --create
    #+END_SRC

    Creates a data volume container with a new database on it
    #+BEGIN_SRC sh :tangle database12.1.0.2.0/software/create_db_volume.sh
      docker create -d --name oradata-container -v /opt/oracle/oraInventory vercapi/oracle_software121 /home/oracle/scripts/create_db.sh
    #+END_SRC

**** Database install scripts on docker

    This is the script on the docker that will actually create the database when the image is used to create a Database volume

    #+HEADERS: :var p_oracle_sid="orcl" :var p_template_file="db_install.dbt"
    #+BEGIN_SRC sh :tangle ./database12.1.0.2.0/software/create_db.sh :dir ./database12.1.0.2.0/dbca
      # File locations
      LSNR_LOC=$ORACLE_HOME/network/admin/listener.ora
      DBCA_RSP_LOC=/home/oracle/config/dbca.rsp

      # Actually configure the install file with the parameters
      sed -i "s/{{ORACLE_SID}}/orcl/" $DBCA_RSP_LOC
      sed -i "s/{{ORACLE_PWD}}/Welcome1/" $DBCA_RSP_LOC
      sed -i "s/{{ORACLE_PDB}}/ORAPDB1/" $DBCA_RSP_LOC

      # Install listener
      mv /home/oracle/config/listener.ora $LSNR_LOC

      # Configure the listener with the actual hostname (name of the container)
      sed -i "s/{{hostname}}/$(hostname)/" $LSNR_LOC

      # Start listener for dbca
      echo "- Starting listener- "
      lsnrctl start

      # Run DBCA, output log on failure
      echo "- Starting dbca -"
      dbca -silent -createdatabase -responseFile $DBCA_RSP_LOC ||
        cat /opt/oracle/app/cfgtoollogs/dbca/${ORACLE_SID,,}/${$ORACLE_SID}.log
      echo "- End dbca -"
    #+END_SRC


*** Run database
   
    #+HEADER: :var minion="orcl.oracletools"
    #+BEGIN_SRC sh :dir /sudo:root@nitro:/home/vercapi/Documents/projects/oracleTools
      docker run -id -h $minion \
             --name $minion \
             -v /srv/docker/volumes/$minion/etc/salt/minion.d:/etc/salt/minion.d \
             -v /srv/docker/volumes/$minion/etc/salt/pki:/etc/salt/pki \
             -p 1521:1521 \
             --net="bridge" \
             vercapi/orcl_121
    #+END_SRC

    Hook into the running container
    #+HEADER: :var minion="orcl.oracletools"
    #+BEGIN_SRC sh :dir /sudo:root@nitro:/home/vercapi/Documents/projects/oracleTools
    docker exec -i -t $minion /bin/bash
    #+END_SRC

    Run docker without the saltstack stuff
    #+BEGIN_SRC sh :dir /sudo:root@nitro:/home/vercapi/Documents/projects/oracleTools
    docker run -id -h orcl.oracletools -p 1521:1521 --name orcl vercapi/orcl_121
    #+END_SRC

**** Run scripts on docker


** New method

   BUILD
   - Build software only install (use existing)
   - dbca install (script) -> Is actualy creating a database
     - Create empty volume (name based with the correct item)
     - Run software only with dbca on startup
       - mount empty volume when running
   
   RUN
   - Run the software only install with the desired volume
