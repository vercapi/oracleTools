#+TITLE: Oracle Tools

* Docker base  

** Base image

  All docker images are based on oracle-minion. This is an oracleLinux image with a saltstack minion installed on it.
  

*** Building the oracle-minion

    Actually build the base minion

    #+BEGIN_SRC sh :dir /sudo::/home/vercapi/Documents/projects/oracleTools/oracle-minion/ :results raw
    docker build -t vercapi/oracle_minion .
    #+END_SRC

*** Supplying the keys for an vercapi/oracle_minion container

    Generate a key move it to the master and supply it so that the docker image can be build with it.
    Before running the minion we need to setup some directories so that the salt state is persisted when the container is destroyed
    * minion.d is the directory to store configuration

    #+NAME: prep_minion
    #+HEADER: :var minion="minion.oracletools"
    #+BEGIN_SRC sh :dir /sudo::/home/vercapi/Documents/projects/oracleTools/oracle-minion/ :results raw
      KEY_NAME=preseed_key
      PUB_KEY_FILE_NAME=$KEY_NAME.pub
      PRIV_KEY_FILE_NAME=$KEY_NAME.pem

      # Prepare the mount points
      MINION_HOME=/srv/docker/volumes/$minion
      mkdir -p $MINION_HOME/etc/salt/minion.d
      mkdir -p $MINION_HOME/etc/salt/pki/minion

      salt-key --gen-keys=$KEY_NAME

      # Copy to master for the minion id $minion
      cp $PUB_KEY_FILE_NAME /etc/salt/pki/master/minions/$minion

      # Copy this to the minion directory
      cp $PRIV_KEY_FILE_NAME $MINION_HOME/etc/salt/pki/minion/minion.pem
      cp $PUB_KEY_FILE_NAME  $MINION_HOME/etc/salt/pki/minion/minion.pub


      # catch
      finish () {
          rm -f $PUB_KEY_FILE_NAME
          rm -f $PRIV_KEY_FILE_NAME
      }

      trap finish EXIT
    #+END_SRC

    #+RESULTS: prep_minion


*** Actually run the container
    
    Test run for the minion. Uses storage for the keys when running
    the bridge is needed so that the minion can connect to the salt master running on the host

    #+HEADER: :var minion="minion.oracletools"
    #+BEGIN_SRC sh :dir /sudo::/home/vercapi/Documents/projects/oracleTools/oracle-minion/ :results raw
      docker run -id -h $minion \
             --name $minion \
             -v /srv/docker/volumes/$minion/etc/salt/minion.d:/etc/salt/minion.d \
             -v /srv/docker/volumes/$minion/etc/salt/pki:/etc/salt/pki \
             --net="bridge" \
             vercapi/oracle_minion
    #+END_SRC

    #+RESULTS:
    4d65a45728964c7b4d9c2776e89b9a3a2c97029f7c6ebc71c7b1b0e66f80964a
    

** TODO Copy between

   To copy between systems.
   This should become the local repo.

   On source

   #+BEGIN_SRC sh
   docker save -o <save image to path> <image name>
   #+END_SRC

   #+BEGIN_SRC sh
   docker load -i <path to image tar file>
   #+END_SRC


* Database

** Preparation steps

   First run the installer to create a response file. Run ./runInstaller and select 'Save response file' on the bottom of the summary step. (This is the last step before actually installing anything) 
   Dowload the installation files from the Oracle Website. Im' using the 64 bit linux version 12.1.0.2.


** Docker

   For flexibility and avoiding full rebuilds we will create the docker in 2 steps. The first step will be creating a software 
   install on the image. The second will actually create a database. This gives the advantage that we can create different dockers
   with different databases based on the same base docker image with the software install.

   If you get an error on disk space add "--storage-opt dm.basesize=20G" to the startup. This will increase the max size of the container.

*** Build the docker for software only

    Docker file: oracleTools/software/database12.1.0.2.0/software/Dockerfile
    
    This docker will be a software only install there is no ready to use database. 

    To get a running database this image can be used to create a datacontainer that has a DB on it. The same image can be used to run the
    resulting container.

    Download of the software needs to happen manually.

    The response file oracleTools/software/database12.1.0.2.0/software/db.rsp contains info like the install directory what users and groups to use.
    You can also configure the starter db here as wel as grid options. None of the are used currently

    #+BEGIN_SRC sh :dir /sudo::/home/vercapi/Documents/projects/oracleTools/software/database12.1.0.2.0/software :results raw
      cp /mnt/localData/stage/linuxamd64_12102_database_1of2.zip ./
      cp /mnt/localData/stage/linuxamd64_12102_database_2of2.zip ./

      docker build -t vercapi/oracle_software121 .

      rm linuxamd64_12102_database_1of2.zip && rm linuxamd64_12102_database_2of2.zip
    #+END_SRC

    Running the docker with a shell to see the installation was successful. Starting the DB will not work but you can check the installed files.
    #+BEGIN_SRC sh :dir /sudo::/home/vercapi/Documents/projects/oracleTools/software/database12.1.0.2.0/software :results raw
      docker run -i -t vercapi/oracle_software121 /bin/bash
    #+END_SRC

    In the container you can check the log files produced in the install command or subsequent scripts.

*** Database volume creation

    Creates a data volume container with a new database on it
    #+BEGIN_SRC sh :tangle database12.1.0.2.0/software/create_db_volume.sh
      docker create -d --name oradata-container -v /opt/oracle/oraInventory vercapi/oracle_software121 /home/oracle/scripts/create_db.sh
    #+END_SRC

**** Scripts provided for docker

    This is the script on the docker that will actually create the database when the image is used to create a Database volume

    #+HEADERS: :var p_oracle_sid="orcl" :var p_template_file="db_install.dbt"
    #+BEGIN_SRC sh :tangle ./database12.1.0.2.0/software/create_db.sh :dir ./database12.1.0.2.0/dbca
      ORACLE_HOME="/opt/oracle/app/product/12.1.0/dbhome"
      PERSISTENT_DATA="/opt/oracle/oraInventory"
      ORACLE_BASE="/opt/oracle/app"

      sed -i "s/{{ db_create_file_dest }}/\/opt\/oracle\/oraInventory\/$p_oracle_sid/" ./db_install.dbt
      sed -i "s/{{ oracle_base }}/\/opt\/oracle\/app/" ./db_install.dbt
      sed -i "s/{{ database_name }}/$p_oracle_sid/" ./db_install.dbt

      $ORACLE_HOME/bin/dbca -silent -createdatabase -templatename /home/oracle/$p_template_file -gdbname $p_oracle_sid -sid $p_oracle_sid -syspassword oracle -systempassword oracle -dbsnmppassword oracle
    #+END_SRC

*** Run database
   
   #+BEGIN_SRC sh :tangle ./database12.1.0.2.0/dbca/run_db.sh
      ORACLE_HOME={{oracle_home}}
      ORACLE_BASE={{oracle_base}}
      ORACLE_SID={{oracle_sid}}

      export ORACLE_HOME ORACLE_SID

      setup_listener() {
          sed -i "s/{{hostname}}/$(hostname)/" $ORACLE_HOME/network/admin/listener.ora
      }

      start_database() {
        $ORACLE_HOME/bin/sqlplus / as sysdba << EOF
        startup
        exit
      EOF
      }

      start_listener() {
          $ORACLE_HOME/bin/lsnrctl start
      }


      setup_listener
      start_listener
      start_database

      # Start the minion last so that it status reflects the processes above
      sudo salt-minion

      # Tail the output of the DB in case of issues
      #tail -f $ORACLE_BASE/diag/rdbms/$ORACLE_SID/*/trace/alert_$ORACLE_SID.log
    #+END_SRC


    #+HEADER: :var minion="orcl.oracletools"
    #+BEGIN_SRC sh :dir /sudo:root@nitro:/home/vercapi/Documents/projects/oracleTools
      docker run -id -h $minion \
             --name $minion \
             -v /srv/docker/volumes/$minion/etc/salt/minion.d:/etc/salt/minion.d \
             -v /srv/docker/volumes/$minion/etc/salt/pki:/etc/salt/pki \
             -p 1521:1521 \
             --net="bridge" \
             vercapi/orcl_121
    #+END_SRC

    Hook into the running container
    #+HEADER: :var minion="orcl.oracletools"
    #+BEGIN_SRC sh :dir /sudo:root@nitro:/home/vercapi/Documents/projects/oracleTools
    docker exec -i -t $minion /bin/bash
    #+END_SRC

    Run docker without the saltstack stuff
    #+BEGIN_SRC sh :dir /sudo:root@nitro:/home/vercapi/Documents/projects/oracleTools
    docker run -id -h orcl.oracletools -p 1521:1521 --name orcl vercapi/orcl_121
    #+END_SRC 


** New method

   BUILD
   - Build software only install (use existing)
   - dbca install (script) -> Is actualy creating a database
     - Create empty volume (name based with the correct item)
     - Run software only with dbca on startup
       - mount empty volume when running
   
   RUN
   - Run the software only install with the desired volume
